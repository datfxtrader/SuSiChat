Step 2: Update DeerFlow Manager Configuration
In your server/deerflow-manager.ts, update the port configuration:
javascript// server/deerflow-manager.ts
export class DeerFlowManager {
  private static readonly DEERFLOW_PORT = process.env.DEERFLOW_PORT || 8000; // Change from 9000 to 8000
  private static readonly DEERFLOW_HOST = process.env.DEERFLOW_HOST || '127.0.0.1'; // Use localhost instead of 0.0.0.0
  private static readonly HEALTH_CHECK_URL = `http://${this.DEERFLOW_HOST}:${this.DEERFLOW_PORT}/health`;
  
  static async checkDeerFlowService(): Promise<boolean> {
    try {
      console.log(`Checking DeerFlow health at ${this.HEALTH_CHECK_URL}`);
      
      const response = await axios.get(this.HEALTH_CHECK_URL, {
        timeout: 3000,
        validateStatus: (status) => status === 200
      });
      
      return response.data?.status === 'healthy';
    } catch (error) {
      console.log(`DeerFlow health check failed:`, error.message);
      return false;
    }
  }
}
Step 3: Update DeerFlow Client Configuration
In your server/deerflow-client.ts, ensure consistent port usage:
javascript// server/deerflow-client.ts
export class DeerFlowClient {
  private baseUrl: string;
  
  constructor() {
    const port = process.env.DEERFLOW_PORT || 8000; // Consistent with manager
    const host = process.env.DEERFLOW_HOST || '127.0.0.1';
    this.baseUrl = `http://${host}:${port}`;
    
    console.log(`DeerFlow Client configured for: ${this.baseUrl}`);
  }
  
  async performResearch(params: DeerFlowResearchParams): Promise<DeerFlowResearchResponse> {
    try {
      console.log(`Making request to DeerFlow service: ${this.baseUrl}/research`);
      
      const response = await axios.post(`${this.baseUrl}/research`, params, {
        timeout: 600000, // 10 minutes
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      return response.data;
    } catch (error) {
      console.error('Error performing DeerFlow research:', error.message);
      throw error;
    }
  }
}
Step 4: Start DeerFlow Service on Correct Port
Create a startup script for DeerFlow:
bash# scripts/start-deerflow.sh
#!/bin/bash

echo "ðŸš€ Starting DeerFlow service on port 8000..."

# Kill any existing DeerFlow processes
pkill -f "python.*deerflow"
sleep 2

# Start DeerFlow service
cd deerflow_service
DEERFLOW_PORT=8000 python server.py &

# Wait for startup
sleep 5

# Check if it's running
if curl -s http://localhost:8000/health > /dev/null; then
    echo "âœ… DeerFlow service started successfully on port 8000"
else
    echo "âŒ DeerFlow service failed to start"
fi
Step 5: Environment Variables
Update your .env file or Replit Secrets:
envDEERFLOW_PORT=8000
DEERFLOW_HOST=127.0.0.1
DEERFLOW_URL=http://127.0.0.1:8000
Step 6: Update Python DeerFlow Server
If you have a Python DeerFlow server, make sure it's configured for port 8000:
python# deerflow_service/server.py
import os
from flask import Flask

app = Flask(__name__)

# Use environment variable or default to 8000
PORT = int(os.environ.get('DEERFLOW_PORT', 8000))
HOST = os.environ.get('DEERFLOW_HOST', '127.0.0.1')

@app.route('/health')
def health():
    return {"status": "healthy", "port": PORT}

if __name__ == '__main__':
    print(f"ðŸš€ Starting DeerFlow service on {HOST}:{PORT}")
    app.run(host=HOST, port=PORT, debug=False)
Step 7: Unified Startup Command
Create a unified startup that ensures both services start correctly:
javascript// server/startup.js
const { spawn } = require('child_process');

async function startServices() {
  console.log('ðŸš€ Starting all services...');
  
  // Start DeerFlow first
  const deerflowProcess = spawn('python', ['deerflow_service/server.py'], {
    env: { 
      ...process.env, 
      DEERFLOW_PORT: 8000,
      DEERFLOW_HOST: '127.0.0.1'
    },
    stdio: 'inherit'
  });
  
  // Wait for DeerFlow to start
  await new Promise(resolve => setTimeout(resolve, 5000));
  
  // Start main server
  const mainProcess = spawn('npm', ['run', 'dev'], {
    env: { 
      ...process.env, 
      PORT: 5000,
      DEERFLOW_PORT: 8000 
    },
    stdio: 'inherit'
  });
  
  // Handle cleanup
  process.on('SIGINT', () => {
    console.log('ðŸ›‘ Shutting down services...');
    deerflowProcess.kill();
    mainProcess.kill();
    process.exit(0);
  });
}

startServices().catch(console.error);
Step 8: Quick Fix for Immediate Testing
For immediate testing, you can bypass DeerFlow entirely by updating your research service to use the enhanced fallback:
javascript// In server/deerflow-integration.ts - temporary bypass
async performDeepResearch(params: ResearchParams): Promise<ResearchResult> {
  console.log('ðŸ”„ Using enhanced fallback research (DeerFlow bypassed)');
  
  // Direct fallback without trying DeerFlow
  return await this.performEnhancedFallback(params);
}
Step 9: Test the Fix
bash# Stop all services
pkill -f "python.*deerflow"
pkill -f "tsx server"

# Set correct environment variables
export DEERFLOW_PORT=8000
export DEERFLOW_HOST=127.0.0.1

# Start DeerFlow manually first
cd deerflow_service && python server.py &

# Wait and test
sleep 5
curl http://localhost:8000/health

# Start main server
cd .. && npm run dev
Step 10: Verify the Fix
You should see in your logs:
DeerFlow Client configured for: http://127.0.0.1:8000
Checking DeerFlow health at http://127.0.0.1:8000/health
âœ… DeerFlow service healthy